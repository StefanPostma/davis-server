'use strict';

const ConversationService = require('../../../services/ConversationService'),
    AccountService = require('../../../services/AccountService'),
    logger = require('../../../utils/logger'),
    Davis = require('../../../core'),
    BbPromise = require('bluebird'),
    _ = require('lodash');

const REQUEST_SOURCE = 'slack';


module.exports = function SlackService(config) {


    /**
     * Responds to Slack using the exchange generated by Davis
     * @param {Object} davis - The fully processed Davis object.
     * @returns {Object} response - The response formatted how Slack expects.
     */
    function formatResponse(davis) {
        logger.info('Generating the response for Slack');
    
        let response = davis.exchange.response.visual.text;
        
        return {
            response: {
                shouldEndSession: _.get(davis, 'exchange.response.finished', true),
                outputSpeech: {
                    type: 'text',
                    text: response
                }
            }
        };
    }

    return {
        /**
         * Interacts with Davis via Slack
         * 
         * @param {Object} req - The request received from Slack.
         * @param {Object} member - Slack member details
         * 
         * @returns {promise} res - The response formatted for Slack.
         */
        askDavis: (req, member) => {
            
            logger.info('Starting our interaction with Davis');
            
            return new BbPromise((resolve, reject) => {
        
                // Use Slack user property as id for Davis user 
                // Avoids having to enter Slack user property for each Davis user for association
                let user = {
                    id: member.id, 
                    name: {
                        'first': member.first_name, 
                        'last': member.last_name
                    },
                    email: member.email,
                    nlp: config.nlp,
                    dynatrace: config.slack.dynatrace,
                    timezone: member.tz
                };
    
                // Starts or continues our conversation
                ConversationService.getConversation(user)
                    .then(conversation => {
                        let davis = new Davis(user, conversation, config);
                        return davis.interact(req.text, REQUEST_SOURCE);
                    })
                    .then(davis => {
                        logger.info('Finished processing request');
                        return resolve(formatResponse(davis));
                    })
                    .catch(err => {
                        logger.error(`Unfortunately, something went wrong.  ${err.message}`);
                        //ToDo Add failure response
                        return reject(err.message);
                    });
            });
            
        }
    }
};